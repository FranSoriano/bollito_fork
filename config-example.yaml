# path or URL to sample sheet (TSV format, columns: sample, condition, ...)
samples: samples.tsv
# path or URL to sequencing unit sheet (TSV format, columns: sample, unit, fq1, fq2)
# Units are technical replicates (e.g. lanes, or resequencing of the same biological
# sample).
units: units.tsv

outdir: 'out/test'
logdir: 'log/test'

# Genomic references
ref:
    annotation: "/scratch/resources/annotations/m_musculus/gencode.vM20.annotation.gtf"
    idx: "/scratch/resources/genomes/m_musculus/GRCm38.primary_assembly.genome_idx_star_2.7.1a"

# barcodes whitelist
whitelist: "res/whitelists/3M-february-2018.txt"

rules:
    default:
        res:
            threads: 1
            mem: 2000
            walltime: 120
# Cut adaptors
    cutadapt:
        disabled: true
        params: "-G GCAGTGGTATCAACGCAGAGTACATGGG -m 16"
# Fastq screen. Screen a library of sequences in fastq format against a set of sequence DBs (of other organisms) to check its composition.
    fastq_screen_indexes:
        threads: 8
        outdir: "res"
    fastq_screen:
        threads: 8
        disabled: true
 # STAR alignment
    star_index:
        res:
            threads: 6
            mem: 64000
    star:
        params: "--soloType Droplet --soloFeatures Gene --outFilterMultimapNmax 50 --winAnchorMultimapNmax 50 --alignEndsType EndToEnd --outReadsUnmapped Fastx --soloUMIlen 12 --outSAMtype BAM SortedByCoordinate"
        res:
            threads: 6
            mem: 64000
# Quality control. 
    fastqc:
        res:
            threads: 4
    rseqc_junction_saturation:
        res:
            mem: 8000
    rseqc_readdup:
        res:
            mem: 24000
 # MultiQC. Aggregate results from FastQC and Rseqc analyses into a single report
    multiqc:
        params: "--config res/config/multiqc_config.yaml"
# Seurat analysis
# step 1. Examine your results with the most commonly used single-cell QC metrics. 
    seurat_qc:
        params:
            # Define the name of your project 
            project_name: "Test"
        res:
            mem: 3000
# step 2. Implement your filters in order to get quality cells using the information gathered in step 1. 
# These quality filters are the following: 
# minimum (min_genes) and maximum (max_genes) number of unique genes detected per cell;
# minimum percentaje of reads mapping to the mitochondrial genome (mit_pct, recommended 5);
# minimum percentaje of reads mapping to the ribosomal genome (ribo_pct, recommended 40)
    seurat_postqc:
        params:
            min_genes: 500
            max_genes: 4000
            mit_pct: 5 
            ribo_pct: 20
        res:
            mem: 4000
# step 2.1. Bollito allows you to filter out cells based on positive or negative marker gene(s).
# Parameters: 
# gene: input a gene or list of genes (i.e. "Epcam")
# threshold: expression-based filtering criteria (i.e. 0)
# filter_out: if true, cells will be filtered out based on the specified threshold; cells with higher expression values will be kept. If false, cells with the will be kept. 
    seurat_filter:
        params:
            gene: 
            threshold:
            filter_out:
        res:
            mem: 4000
# step 3. After normalization, generates a Jackstrawplot as well as an elbow plot.
# Examine these plots in order to select the number of principal components used in the next steps.
    seurat_normalization:
        res:
            mem: 12000
# step 4. Clustering of your data. 
# Paramters:
# random_seed: ensures the reproducibility of your analysis.
# principal_components: number of components used.
# resolutions: the resolution(s) values will set the granularity of the clustering (typicaly between 0.4-1.2). 
    seurat_find_clusters:
        params:
            random_seed: 8458
            principal_components: 50
            resolutions: [0.2, 0.4, 0.8, 1.2]
        res:
            mem: 8000
# step 5. Marker and Differentially expressed genes calculation.
# Parameters: 
# res: sets the resolution to be used in the downstream analysis. 
    seurat_degs:
        params:
            selected_res: 0.2
        res:
            mem: 12000
# step 6. Gene set scoring will calculate the average expression levels of each specified regulatory program.
# Parameters:
# geneset_collection: input a .gmt file with the  gene set or gene set collections to evaluate. 
    seurat_gs:
        params:
            geneset_collection: "c2.cp.kegg.v6.2.symbols.gmt"
        res:
            mem: 10000
